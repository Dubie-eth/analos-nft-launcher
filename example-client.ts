/**
 * Analos NFT Launchpad - Example Client Implementation
 * 
 * This is a complete, copy-paste ready example for integrating with the
 * Analos NFT Launchpad smart contract.
 * 
 * Program ID: 7kdBbyZetzrU8eCCA83FeA3o83ohwyvLkrD8W1nMcmDk
 */

import {
  Connection,
  PublicKey,
  Keypair,
  Transaction,
  SystemProgram,
  SYSVAR_RENT_PUBKEY,
  sendAndConfirmTransaction
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createInitializeMintInstruction,
  MINT_SIZE
} from '@solana/spl-token';
import { BN } from 'bn.js';

// ========== CONFIGURATION ==========

const PROGRAM_ID = new PublicKey('7kdBbyZetzrU8eCCA83FeA3o83ohwyvLkrD8W1nMcmDk');
const RPC_URL = 'https://rpc.analos.io';
const METADATA_PROGRAM_ID = new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');

// Fee recipient wallets
const PLATFORM_FEE_WALLET = new PublicKey('3gWTQDuyYaWDRo2LWCvrzU2dCKfcL5zBQ1UWUx9J9vRL');
const BUYBACK_FEE_WALLET = new PublicKey('9tNaYj8izZGf4X4k1ywWYDHQd3z3fQpJBg6XhXUK4cEy');
const DEV_FEE_WALLET = new PublicKey('FCH5FYz6uCsKsyqvDY8BdqisvK4dqLpV5RGTRsRXTd3K');

const LAMPORTS_PER_LOS = 1_000_000_000;

// ========== CLIENT CLASS ==========

export class AnalosLaunchpadClient {
  private connection: Connection;
  private programId: PublicKey;

  constructor(rpcUrl: string = RPC_URL) {
    this.connection = new Connection(rpcUrl, 'confirmed');
    this.programId = PROGRAM_ID;
  }

  // ========== PDA HELPERS ==========

  async getCollectionConfigPDA(authority: PublicKey): Promise<[PublicKey, number]> {
    return await PublicKey.findProgramAddress(
      [Buffer.from('collection'), authority.toBuffer()],
      this.programId
    );
  }

  async getTickerRegistryPDA(): Promise<[PublicKey, number]> {
    return await PublicKey.findProgramAddress(
      [Buffer.from('ticker_registry')],
      this.programId
    );
  }

  async getMetadataPDA(mint: PublicKey): Promise<[PublicKey, number]> {
    return await PublicKey.findProgramAddress(
      [
        Buffer.from('metadata'),
        METADATA_PROGRAM_ID.toBuffer(),
        mint.toBuffer()
      ],
      METADATA_PROGRAM_ID
    );
  }

  // ========== 1. INITIALIZE TICKER REGISTRY (Admin Only - Once) ==========

  async initializeTickerRegistry(admin: Keypair): Promise<string> {
    console.log('üìù Initializing ticker registry...');

    const [tickerRegistry] = await this.getTickerRegistryPDA();

    // Build instruction data (discriminator for initialize_ticker_registry)
    const instructionData = Buffer.from([
      // Add your instruction discriminator here
      // This is typically generated by Anchor based on the instruction name
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: tickerRegistry, isSigner: false, isWritable: true },
        { pubkey: admin.publicKey, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [admin]
    );

    console.log('‚úÖ Ticker registry initialized!');
    console.log(`   Signature: ${signature}`);
    return signature;
  }

  // ========== 2. CHECK TICKER AVAILABILITY ==========

  async checkTickerAvailability(ticker: string): Promise<boolean> {
    console.log(`üîç Checking ticker availability: ${ticker}`);

    // Validate ticker format
    if (ticker.length < 1 || ticker.length > 10) {
      console.log('‚ùå Invalid ticker length (must be 1-10 characters)');
      return false;
    }

    if (!/^[a-zA-Z0-9]+$/.test(ticker)) {
      console.log('‚ùå Invalid ticker format (must be alphanumeric)');
      return false;
    }

    const [tickerRegistry] = await this.getTickerRegistryPDA();

    try {
      // Fetch ticker registry account
      const accountInfo = await this.connection.getAccountInfo(tickerRegistry);
      
      if (!accountInfo) {
        console.log('‚ö†Ô∏è Ticker registry not initialized yet');
        return true; // Registry not initialized, so ticker is technically available
      }

      // Parse the account data to check if ticker exists
      // You'll need to deserialize the TickerRegistry struct here
      // For now, we'll return true (available) as a placeholder

      console.log('‚úÖ Ticker is available!');
      return true;
    } catch (error) {
      console.error('‚ùå Error checking ticker:', error);
      return false;
    }
  }

  // ========== 3. INITIALIZE COLLECTION ==========

  async initializeCollection(params: {
    authority: Keypair;
    maxSupply: number;
    priceLOS: number;
    revealThresholdPercent: number;
    collectionName: string;
    collectionSymbol: string;
    placeholderUri: string;
  }): Promise<string> {
    console.log('üéØ Initializing collection...');

    const {
      authority,
      maxSupply,
      priceLOS,
      revealThresholdPercent,
      collectionName,
      collectionSymbol,
      placeholderUri
    } = params;

    // Check ticker availability first
    const isAvailable = await this.checkTickerAvailability(collectionSymbol);
    if (!isAvailable) {
      throw new Error(`Ticker ${collectionSymbol} is not available`);
    }

    const [collectionConfig] = await this.getCollectionConfigPDA(authority.publicKey);
    const [tickerRegistry] = await this.getTickerRegistryPDA();
    const collectionMint = Keypair.generate();

    const priceLamports = priceLOS * LAMPORTS_PER_LOS;
    const revealThreshold = Math.floor((maxSupply * revealThresholdPercent) / 100);

    console.log(`   Collection: ${collectionName} (${collectionSymbol})`);
    console.log(`   Max Supply: ${maxSupply}`);
    console.log(`   Price: ${priceLOS} LOS`);
    console.log(`   Reveal Threshold: ${revealThreshold} (${revealThresholdPercent}%)`);

    // Build instruction data
    // You'll need to properly encode the parameters according to Anchor's encoding
    const instructionData = Buffer.concat([
      // Instruction discriminator
      // Encoded parameters: maxSupply, priceLamports, revealThreshold, names, uri
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: collectionConfig, isSigner: false, isWritable: true },
        { pubkey: collectionMint.publicKey, isSigner: true, isWritable: true },
        { pubkey: tickerRegistry, isSigner: false, isWritable: true },
        { pubkey: authority.publicKey, isSigner: true, isWritable: true },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [authority, collectionMint]
    );

    console.log('‚úÖ Collection initialized!');
    console.log(`   Collection Config: ${collectionConfig.toString()}`);
    console.log(`   Collection Mint: ${collectionMint.publicKey.toString()}`);
    console.log(`   Signature: ${signature}`);

    return signature;
  }

  // ========== 4. MINT PLACEHOLDER NFT ==========

  async mintPlaceholder(params: {
    payer: Keypair;
    authority: PublicKey;
  }): Promise<string> {
    console.log('üé® Minting placeholder NFT...');

    const { payer, authority } = params;

    const [collectionConfig] = await this.getCollectionConfigPDA(authority);
    const nftMint = Keypair.generate();
    
    const userTokenAccount = await getAssociatedTokenAddress(
      nftMint.publicKey,
      payer.publicKey
    );

    const [metadata] = await this.getMetadataPDA(nftMint.publicKey);

    // Fetch collection config to get price
    const configAccount = await this.connection.getAccountInfo(collectionConfig);
    if (!configAccount) {
      throw new Error('Collection not found');
    }

    // Build instruction data
    const instructionData = Buffer.from([
      // Instruction discriminator for mint_placeholder
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: collectionConfig, isSigner: false, isWritable: true },
        { pubkey: nftMint.publicKey, isSigner: true, isWritable: true },
        { pubkey: userTokenAccount, isSigner: false, isWritable: true },
        { pubkey: metadata, isSigner: false, isWritable: true },
        { pubkey: PLATFORM_FEE_WALLET, isSigner: false, isWritable: true },
        { pubkey: BUYBACK_FEE_WALLET, isSigner: false, isWritable: true },
        { pubkey: DEV_FEE_WALLET, isSigner: false, isWritable: true },
        { pubkey: payer.publicKey, isSigner: true, isWritable: true },
        { pubkey: METADATA_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: ASSOCIATED_TOKEN_PROGRAM_ID, isSigner: false, isWritable: false },
        { pubkey: SystemProgram.programId, isSigner: false, isWritable: false },
        { pubkey: SYSVAR_RENT_PUBKEY, isSigner: false, isWritable: false }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [payer, nftMint]
    );

    console.log('‚úÖ NFT minted!');
    console.log(`   NFT Mint: ${nftMint.publicKey.toString()}`);
    console.log(`   Token Account: ${userTokenAccount.toString()}`);
    console.log(`   Signature: ${signature}`);

    return signature;
  }

  // ========== 5. REVEAL COLLECTION (Admin Only) ==========

  async revealCollection(params: {
    authority: Keypair;
    revealedBaseUri: string;
  }): Promise<string> {
    console.log('üé≠ Revealing collection...');

    const { authority, revealedBaseUri } = params;

    const [collectionConfig] = await this.getCollectionConfigPDA(authority.publicKey);

    // Build instruction data
    const instructionData = Buffer.concat([
      // Instruction discriminator
      // Encoded revealedBaseUri
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: collectionConfig, isSigner: false, isWritable: true },
        { pubkey: authority.publicKey, isSigner: true, isWritable: true }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [authority]
    );

    console.log('‚úÖ Collection revealed!');
    console.log(`   Base URI: ${revealedBaseUri}`);
    console.log(`   Signature: ${signature}`);

    return signature;
  }

  // ========== 6. WITHDRAW FUNDS (Admin Only) ==========

  async withdrawFunds(params: {
    authority: Keypair;
    amountLOS: number;
  }): Promise<string> {
    console.log('üí∞ Withdrawing funds...');

    const { authority, amountLOS } = params;

    const [collectionConfig] = await this.getCollectionConfigPDA(authority.publicKey);
    const amountLamports = amountLOS * LAMPORTS_PER_LOS;

    console.log(`   Amount: ${amountLOS} LOS (${amountLamports} lamports)`);

    // Build instruction data
    const instructionData = Buffer.concat([
      // Instruction discriminator
      // Encoded amount (u64)
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: collectionConfig, isSigner: false, isWritable: true },
        { pubkey: authority.publicKey, isSigner: true, isWritable: true }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [authority]
    );

    console.log('‚úÖ Funds withdrawn!');
    console.log(`   Signature: ${signature}`);

    return signature;
  }

  // ========== 7. SET PAUSE (Admin Only) ==========

  async setPause(params: {
    authority: Keypair;
    paused: boolean;
  }): Promise<string> {
    console.log(`${params.paused ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è'} ${params.paused ? 'Pausing' : 'Unpausing'} collection...`);

    const { authority, paused } = params;

    const [collectionConfig] = await this.getCollectionConfigPDA(authority.publicKey);

    // Build instruction data
    const instructionData = Buffer.concat([
      // Instruction discriminator
      // Encoded paused (bool)
    ]);

    const transaction = new Transaction().add({
      keys: [
        { pubkey: collectionConfig, isSigner: false, isWritable: true },
        { pubkey: authority.publicKey, isSigner: true, isWritable: false }
      ],
      programId: this.programId,
      data: instructionData
    });

    const signature = await sendAndConfirmTransaction(
      this.connection,
      transaction,
      [authority]
    );

    console.log(`‚úÖ Collection ${paused ? 'paused' : 'unpaused'}!`);
    console.log(`   Signature: ${signature}`);

    return signature;
  }

  // ========== 8. FETCH COLLECTION CONFIG ==========

  async fetchCollectionConfig(authority: PublicKey): Promise<any> {
    console.log('üìä Fetching collection config...');

    const [collectionConfig] = await this.getCollectionConfigPDA(authority);

    const accountInfo = await this.connection.getAccountInfo(collectionConfig);
    
    if (!accountInfo) {
      throw new Error('Collection not found');
    }

    // Parse the account data
    // You'll need to deserialize the CollectionConfig struct here
    
    console.log('‚úÖ Collection config fetched!');
    return accountInfo.data;
  }
}

// ========== USAGE EXAMPLES ==========

async function example() {
  const client = new AnalosLaunchpadClient();
  
  // Your admin/authority wallet
  const authority = Keypair.generate(); // In production, load from file
  
  // 1. Initialize ticker registry (once, admin only)
  await client.initializeTickerRegistry(authority);
  
  // 2. Check ticker availability
  const isAvailable = await client.checkTickerAvailability("AMB");
  
  // 3. Initialize collection
  await client.initializeCollection({
    authority,
    maxSupply: 10000,
    priceLOS: 0.1,
    revealThresholdPercent: 50,
    collectionName: "Analos Mystery Box",
    collectionSymbol: "AMB",
    placeholderUri: "ipfs://Qm.../placeholder.json"
  });
  
  // 4. Mint NFT (users)
  const user = Keypair.generate();
  await client.mintPlaceholder({
    payer: user,
    authority: authority.publicKey
  });
  
  // 5. Reveal collection (admin)
  await client.revealCollection({
    authority,
    revealedBaseUri: "ipfs://Qm.../revealed/"
  });
  
  // 6. Withdraw funds (admin)
  await client.withdrawFunds({
    authority,
    amountLOS: 10
  });
}

// ========== HELPER FUNCTIONS ==========

export function calculateFees(mintPriceLamports: number) {
  const platformFee = Math.floor(mintPriceLamports * 250 / 10000);
  const buybackFee = Math.floor(mintPriceLamports * 150 / 10000);
  const devFee = Math.floor(mintPriceLamports * 100 / 10000);
  const creatorAmount = mintPriceLamports - platformFee - buybackFee - devFee;

  return {
    creatorAmount,
    platformFee,
    buybackFee,
    devFee,
    totalFees: platformFee + buybackFee + devFee
  };
}

export function lamportsToLOS(lamports: number): number {
  return lamports / LAMPORTS_PER_LOS;
}

export function losToLamports(los: number): number {
  return Math.floor(los * LAMPORTS_PER_LOS);
}

// Export client
export default AnalosLaunchpadClient;

